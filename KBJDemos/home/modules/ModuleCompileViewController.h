//
//  ModuleCompileViewController.h
//  KBJDemos
//
//  Created by Juster on 2018/8/6.
//  Copyright © 2018年 Juster. All rights reserved.
//

#import <UIKit/UIKit.h>
#import "FileAViewController.h"
#import "FileBViewController.h"



/**
 通过File A,File B测试AB包含同一个enum是否可用
    * File A,B同时定义各自使用，没有问题，但是如果都被某一个文件引入了就会出现重复定义的问题
    * 只改枚举名字也是不行的，导致枚举里面的内容重复定义
    * 结论--两个都要改才行
 测试包含相同类型block定义是否可用
    * 枚举名称不能和block同名
    * bcok分别在ab定义
    * 结论--block只是表明类型，可以不同文件定义相同名称的block
 通过不同工程测试是否包含相同文件名的文件是否可用(iOS的命名空间是整个app还是一个project？)
    * 博主在对一个大型项目进行组件化，通过实践，结论--不同工程否包含相同文件名的文件编译失败
    * 结论--iOS的命名空间是整个app不管里面有多少个工程(其实这个没必要实践，苹果要求app有自己的前缀的原因就在于此啊)
 
 *** 协议可以前向引用任何类，及时工程中没有这个类
 
 ###########################################################
 关于继承：A为一个VC
 A的子类默认调用A的无参构造函数
 A的子类显示后，A默认也会调用viewDidLoad
 ###########################################################
 组件化拆离方案总结
 1.先梳理A组件与其他组件相关的文件(类、方法(实例、类对象)、属性、枚举、宏)
 2.继承解耦(比如A继承了B的一个类)
    采用继承方案：自第三方父类(比如UIKit其实也是第三方)进行解耦，注意属性继承、方法继承(这里尤其注意代理问题)
    采用组合方案：协议+代理，和上面类似，多了一步转发，好处是容易引入AOP
 3.依赖解耦(比如A直接依赖B的文件)
    采用门面模式：
        A写接口+实现
        B实现接口
        A接口的实现转发给B的实现接口
    这么做的好处是，A对B依赖就单独的靠那几个接口实现类(门面模式)，同时融入引入AOP
 4.对于属性
    仔细想想，属性也是方法，所以可以走方法的处理，我们这边遇到A的一个类用到了B累的view(这是个属性~)
    直接暴露出来这个属性或者方法，然后访问即可
 5.宏或者枚举
    这就需要根据业务划分了，业务依赖的放入第三方，可以不依赖的各自维护
 6.类实例和类对象
    其实这个没什么太大分别，只是+ - 号问题
 7.测试~测试~测试~
    一定要根据现在的情况写stub，接口有了那么就直接继承自原类并实现接口(这样你这类就是个空壳类)
    但是他可以起到很好的测试，因为你要讲原来的依赖依赖自己，所以这个是很需要的
    写一个，要测一个！
 8.不是编译过了就行了
    组件化整理需要编译时最低要求啊，业务，业务，业务，多测试不要影响显著的业务
 
 其次，解耦时应考虑组件本身与其他组件依赖关系，考虑先大局再局部（先进行小类-model等基础类，在对容器类--vc封装类解耦）
 
 ###########################################################
 组件化解耦
 * 单利对象
    直接协议+实现，需要注意单例对象是否依赖了实例对象
 * 类对象
    直接协议+类实现
 * 实例对象
    这是最难的，需要先分析依赖关系，应该封装什么，封装程度
    根据情况封装，避免依赖，有时候需要将一组操作直接封装起来
 
 组件化内容对外暴露
    * 接口
        能用接口用接口，不能用考虑底层类（比如涉及很广，用接口不方便）
    * 父类（抽象或者公共）--》我们这里由于继承了下层库，暴露处采用对外暴露父类，不是本类
        对外父类，实现用子类
 ###########################################################
 写组件应该注意什么
 随时重构，讲道理真的
 1.考虑这个东西后期可能会组件化，那么就要调整里面的东西为id<>
    随时准备面向接口编程~
 2.下沉还是暴露
    不涉及业务，可以考虑下沉到第三方或者新创一个基础库
    涉及到业务，想办法协议
 ###########################################################
 组件化遇到了一个死循环问题~多么痛的领悟
 单例导致的死锁~
 具体说明：
 A B两个组件
 
 a b分别是AB里面的组件文件，根据组件间的依赖需要ab都是依赖于协议
    要求需要通过pyramid取a b的协议实现，我们叫做service
 
 a（单例对象）里面包含b作为属性，b在init的时候使用到了a
 
     a-- file
        property b
         --init {
          id<b> _b = pyramid createService:@protocol(b);
         }
     b-- file
        init
         {
            id<b> a = pyramid createService:@protocol(a);
             if([a somemthod])//optmized
             {
                 do something;
             }
         }
     a_service:a<a>
     b_service:b<b>
 
 说明：pyramid createService每次都是新建对象
      因为比较懒，对a暴露的protocol直接复制了a的方法，然后service继承a（默认实现了）机智吧
 坑来了：
    死循环递归生成ab，原因：pyramid createService每次都是新建对象，a-》b-》a。。
    dispatch_once_t控制不就行了？===》线程死锁，原因：https://blog.csdn.net/fishmai/article/details/52047249
    dispatch_once本质上可以接受多次请求，会对此维护一个请求链表
    如果在block执行期间，多次进入调用同类的dispatch_once函数（即单例函数），会导致整体链表无限增长，造成永久性死锁。
 
 解决方案：a的service不再继承
         b的init不再生成a的service
            ****二者必须同时满足
 
 
 */
@interface ModuleCompileViewController : UIViewController

@property(nonatomic,copy) ModuleCompleBlock block;
@property(nonatomic,assign) ModuleCompleEnum compileA;
@property(nonatomic,assign) ModuleCompleBEnum compileB;

@end
